# 1. 操作系统概述

















## 1.1 操作系统的概念功能



### 操作系统的概念

- 负责管理协调硬件、软件等计算机资源的工作
- 为上层用户、应用程序提供简单易用的服务
- 是一种系统软件



### 操作系统的功能和目标

- 资源管理者
  - 处理机管理
  - 存储器管理
  - 文件管理
  - 设备管理
- 向上层提供服务
  - 给普通用户的
    - GUI界面
    - 命令接口
      - 联机命令接口
      - 脱机命令接口
  - 给程序员使用的
    - 程序接口
      - 系统调用
- 对硬件机器的扩展
  - 在裸机上安装的操作系统， 可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能 更强、使用更方便的机器













## 1.2 操作系统的特征







### 操作系统的四个特征





#### 1.并发（基本特征）

并发：指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的

并行：指两个或多个事件在同一时刻同时发生





#### 2.共享（基本特征）

- 互斥共享

​		一个时间段内只允 许一个进程访问该资源

- 同时共享

​		允许一个时间段 内由多个进程“同时”对它们进行访问

互斥共享方式：使用QQ和微信视频。同一时间段内摄像头只能分配给其中一个进程。 

同时共享方式：使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件， 说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。









#### 3.虚拟

虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。



虚拟技术中的“空分复用技术”。微观上内存在各个微小的时间段内交替 着为各个进程服务

虚拟技术中的“时分复用技术”。微观上处理机在各个微小的时间段内交替 着为各个进程服务







#### 4.异步

异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的， 而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。

如果失去了并发性，即系统只能串行地 运行各个程序，那么每个程序的执行会 一贯到底。只有系统拥有并发性，才有 可能导致异步性。





#### 各个特征之间的关系



并发和共享互为存在条件 

没有并发和共享，就谈不上虚拟和异步，

因此并发和共享是操作系统的两个最基本的特征





并发与共享的关系

使用QQ发送文件A，同时使用微信发送文件B。 

1、两个进程正在并发执行（并发性） 

2、需要共享地访问硬盘资源（共享性）









## 1.3 操作系统的发展和分类



### 1.手工操作阶段



### 2.批处理阶段



#### 单道批处理系统

​	引入脱机输入输出技术，内存中仅能 有一道程序运行，只有该程序运行结束之后才 能调入下一道程序。

​	优点：缓解人机交互速度

​	缺点：存中仅能 有一道程序运行，只有 该程序运行结束之后才 能调入下一道程序。 CPU有大量的时间是在 空闲等待I/O完成。





#### 多道批处理系统

​	优点：多道程序并发执行，共享计算机资源。

​	缺点：不提供人机交互







### 3.分时操作系统

​	计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互。

​	优点：用户请求可以被即时响应，解决了人机交互问题

​	缺点：不能优先处理一些紧急任务







### 4.实时操作系统

硬实时操作系统：要在严格的时限内处理完事件。

软实时操作系统：能接受偶尔违反时间规定









## 1.4 操作系统的运行机制与体系结构



### 运行机制

两种指令：特权指令和非特权指令

两种处理器状态：核心态（特权指令、非特权指令都可以执行）和用户态（cpu只执行非特权指令）

​	用程序状态字寄存器(PSW)中的某标志位来标识当前处理器处于什么状态。如0为用户态,1为核心态

两种程序：内核程序和应用程序



1,特权指令只能在核心态下执行

2.内核程序只能在核心态下执行



### 操作系统内核

内核是计算机上配置的底层软件，是操作系统最基本、最核心的部分。

实现操作系统内核功能的那些程序就是内核程序。

![image-20220524163713622](https://s2.loli.net/2022/05/24/YJQTjWwZ2copef3.png)

![image-20220524163610773](https://s2.loli.net/2022/05/24/V1nLk4JIUQdPrZx.png)







### 体系结构

![image-20220524163738319](https://s2.loli.net/2022/05/24/aXiMHEuj2AsyQ3x.png)













## 1.5 中断和异常



### 中断的概念和作用

1.当中断发生时，CPU立即进入核心态

2.当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理

3.对于不同的中断信号，会进行不同的处理



#### 用户态和核心态之间的切换

中断可以使CPU从用户态切换为核心态，使操作系统获得计算机的控制权

“用户态→核心态”是通过中断实现的。并且中断是唯一途径。

“核心态→用户态”的切换是通过执行一个特权指令,将程序状态字(PSW)的标志位设置为“用户态”





### 中断的分类

- 内中断（信号来源cpu内部）
  - 自愿中断：系统调用（陷入指令，trap指令）
  - 强迫中断：硬件故障（缺页），软件中断（除0）
- 外中断（信号来源cpu外部）
  - 外设请求
  - 人工干预





### 外中断处理过程

每条指令执行结束后, CPU检查是否有外部中断信号

若有外部中断信号,则需要保护被中断进程的CPU环境

根据中断信号类型转入相应的中断处理程序

恢复原进程的CPU环境并退出中断,返回原进程继续往下执行









## 1.6 系统调用



### 系统调用的概念

操作系统提供给应用程序的接口

应用程序通过系统调用请求获得操作系统的服务

系统调用可以使处理器从用户态进入核心态

![image-20220524165440498](https://s2.loli.net/2022/05/24/iX98WPdBZHCU1LQ.png)







### 系统调用和库函数的区别

系统调用是操作系统向上层提供接口

库函数是对系统调用的进一步封装

通过高级语言提供的库函数来间接的进行系统调用





### 系统调用的过程

1. 传递系统调用参数
2. 执行陷入指令
3. 执行系统调用相应服务程序
4. 返回用户程序

系统调用发生在用户态，对系统调用的处理发生在核心态















# 2. 进程与线程









## 2.1 进程与线程







### 2.1.1 进程的定义 组成 组织方式 特征



#### 进程的定义

- 进程就是一个指令序列
- **PCB**，**程序段，数据段**三部分构成了进程实体
- PCB（进程控制块），用来描述进程的各种信息
- **PCB是进程存在的唯一标志**
- 进程是进程实体的运行过程，是系统进行**资源分配**和**调度**的一个独立单位



#### 进程的组织

- 链接方式
  - 按照进程状态将PCB分为多个队列
  - 操作系统持有指向各个队列的指针

执行指针（当前处于运行态的进程）

就绪队列指针（处于就绪态的进程）

阻塞队列指针（处于阻塞态的进程）

指针指向的都是队列，优先级高的进程在队头



- 索引方式
  - 根据进程状态的不同，建立几张索引表
  - 操作系统持有指向各个索引表的指针

执行指针（当前处于运行态的进程）

就绪队列指针（处于就绪态的进程）

阻塞队列指针（处于阻塞态的进程）

指针指向的都是索引表



#### 进程的特征

动态性：最基本的特征

并发性

独立性：进程是资源分配，接受调度的基本单元

异步性

结构性

















### 2.1.2 进程的状态与转换



#### 进程的状态

运行状态：占用cpu

就绪状态：已具备运行条件，由于无空闲CPU，而不能运行

阻塞状态：因等待某事件而不能运行

创建状态：进程正在被创建，初始化PCB，分配资源

终止状态：撤销进程，撤销PCB,撤销资源







#### 进程之间的状态转换



![image-20220525160717476](https://s2.loli.net/2022/05/25/JBbvGghxdWZLVUe.png)











### 2.1.3 进程的控制



进程控制就是实现进程状态转换，即五个状态之间的转换



#### 实现进程控制

使用原语实现，这种不可以被中断的操作即原子操作

原语采用“关中断指令”和“开中断指令”实现

![image-20220525163128784](https://s2.loli.net/2022/05/25/GxALRa6Yd94wFDZ.png)

关/开中断指令的权限非常大,必然是只允许在核心态下执行的特权指令



进程控制需要完成的步骤

1.更新PCB中的信息(如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境)

​	a.所有的进程控制原语一定都会修改进程状态标志

​	b.剥夺当前运行进程的CPU使用权必然需要保存其运行环境

​	c.某进程开始运行前必然要恢复期运行环境

2.将PCB插入合适的队列

3.分配/回收资源









### 2.1.4 进程通信

进程通信就是进程之间的信息交换

进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的**内存地址空间相互独立**。

进程之间不能直接访问对方的地址空间

进程的通信分三种：

- 共享存储
- 消息传递
- 管道通信



#### 共享存储

![image-20220526153048418](https://s2.loli.net/2022/05/26/n3J6NLDs9Z54xzo.png)



#### 管道通信

![image-20220526153305868](https://s2.loli.net/2022/05/26/nt8oGW5Fh7deMOV.png)





#### 消息传递

![image-20220526153349861](https://s2.loli.net/2022/05/26/GebVajh7fEDldnU.png)



















### 2.1.5 线程概念与多线程模型

有的进程需要“同时”做很多事，而传统的进程只能串行的执行一些列程序，需要引入**线程**增加并发度

传统的进程是程序执行流的最小单位

引入线程后，**线程**成为了**程序执行流的最小单位**

**进程**作为出CPU外的**系统资源的分配单元**；**线程**作为**CPU的分配单元**

进程之间可以并发，进程内的各线程之间也可以并发



系统开销：

- 传统的进程间并发，需要切换进程的运行环境，系统开销很大
- 线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小
- 引入线程后，并发所带来的系统开销减小



![image-20220526154054998](https://s2.loli.net/2022/05/26/OjSIltWeMsbC61x.png)



#### 线程的实现方式

- 用户级线程

用户级线程由程序通过线程库实现，所有线程都由应用程序负责。线程的切换在用户态下即可完成。

在用户看来为多个线程，在操作系统内核看来，并意识不到线程的存在



- 内核级线程

内核级线程的管理工作由操作系统的内核完成，切换在核心态下完成

**内核级线程才是处理机分配的单元**







#### 多线程模型

由几个用户级线程映射到几个内核级线程的问题引出了“多线程模型”问题。



##### 多对一

多个用户级线程应设一个内核级线程

优：进程管理开销小效率高

缺：一个线程阻塞会导致整个进程都被阻塞(并发度低)



##### 一对一

一个用户级线程应设一个内核级线程

优：各个线程可分配到多核处理机并行执行，并发度高

缺：进程管理开销大



##### 多对多

多个用户级线程应设多个内核级线程

集二者之所长







## 2.2 处理机调度









### 2.2.1 处理机调度的概念、层次



- 高级调度（作业调度）

从外存上处于后备队列的作业中挑选一个或多个作业给他们分配内存资源，并建立相应的进程

高级调度是**外存**与**内存**之间的调度。高级调度主要指**调入**的问题



- 中间调度（内存调度）

将处于挂起状态的进程调入内存。

挂起状态：暂时调到外存等待的进程状态



- 低级调度（进程调度）

按照某种规则，从就绪队列中选择一个进程为其分配CPU



![image-20220530154124719](https://s2.loli.net/2022/05/30/L4Qikn2Hvohjdz6.png)

![image-20220527162625588](https://s2.loli.net/2022/05/27/YOK3sBndPpFlTqU.png)









### 2.2.2 进程调度的时机，切换过程，调度方式



#### 进程调度的时机

当前运行的进程主动放弃CPU:	进程正常终止，进程主动请求阻塞等等

当前运行的进程被动放弃CPU:	分给进程的时间片用完，有更高优先级的进程等等



不能进行进程调度的情况：

- 在处理中断的过程
- 进程在操作系统内核程序临界区
- 原子操作过程中

内核程序临界区一般是用来访问某种内核数据的，比如进程的就绪队列





#### 进程调度的方式

非剥夺调度方式：直到该进程终止或进入阻塞态

剥夺调度方式：可以优先处理更紧急的进程。





#### 进程的切换过程

狭义进程的调度就是指从就绪队列中选一个要运行的进程

进程切换是指一个进程让出处理机，另一个进程占用处理机



广义的进程调度包含了选择一个进程和进程切换两个步骤







### 2.2.3 调度算法的评价标准



- CPU利用率

利用率=忙碌时间/总时间



- 系统吞吐量

系统吞吐量：单位时间内完成的作业数量



- 周转时间

周转时间 = 作业完成时间-作业提交时间

平均周转时间 = 各作业周转时间/作业数

带权周转时间 = 周转时间/作业实际运行时间



- 等待时间

等待时间 = 等待处理机状态时间之和

对进程来说，指进程建立后等待被服务的时间之和

对于作业来说，建立进程后的等待时间，加上作业在外存后备队列等待的时间



- 响应时间

用户提交请求到首次产生响应的时间





​      



### 2.2.4 调度算法：先来先服务，最短作业优先，最高响应比优先



#### 先来先服务（FCFS,First Come First Serve）

算法规则：按照作业/进程到达的先后顺序进行服务

非抢占式算法

优点：公平，算法简单

缺点：某些程序带权周转时间长，FCFS算法对长作业有利，对短作业不利

饥饿：不会产生饥饿





#### 短作业优先（SJF,Shortest Job First）,短进程优先（SPF）

算法规则：最短作业/进程优先得到服务

算法思想：追求最短的平均等待时间，最少的平均等待时间，最少的平均带权周转时间

一般为非抢占式

优点：对短作业有利

饥饿：可能产生饥饿现象





#### 最短剩余时间优先算法（SRTN）,抢占式的短作业优先算法

每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间短，则由新进程抢占处理机





#### 高响应比优先（HRRN，Highest Response Ratio Next）

算法规则：每次调度时先计算各个作业进程的响应比，选择响应比高的作业/进程服务

响应比：等待时间+要求服务时间/要求服务时间

非抢占式

优缺点：综合以上算法

饥饿：不会



![image-20220530161127694](https://s2.loli.net/2022/05/30/diVp1rX3zIMJyEw.png)



这些算法都适用于**批处理系统**









### 2.2.5 调度算法：时间片轮转，优先级调度，多级反馈队列





#### 时间片轮转调度算法

算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片

用于进程调度

抢占式算法

优点：公平，响应快

缺点：由于高频率的进程切换，有一定开销，不分任务紧急程度

饥饿：不会导致饥饿



#### 优先级调度算法

算法规则：每个进程/作业都有各自的优先级，调度时选择优先级最高的作业

用于作业调度，也可用于进程调度

抢占式和非抢占式都有

优缺点：可以区分紧急程度

饥饿：会导致饥饿





根据优先级是否可以动态改变，将优先级分为静态优先级和动态优先级

**静态优先级**:创建进程时确定,之后一直不变。

**动态优先级**:创建进程时有一个初始值,之后会根据情况动态地调整优先级。

**系统进程**优先级高于**用户进程**

**前台进程**优先级高于**后台进程**

操作系统更偏好**I/O型进程**(或称I/O繁忙型进程)







#### 多级反馈队列调度算法

**算法规则**：1.设置多级就绪队列，各级队列优先级从高到低，时间片从小到大

​	2.新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾如果此时已经是在最下级的队列，则重新放回该队列队尾

​	3.只有第k级队列为空时，才会为k+1级队头的进程分配时间片

用于**进程调度**

**抢占式**算法。

**优缺点**：对各类型进程相对公平(FCFS的优点);每个新到达的进程都可以很快就得到响应(RR的优点) ;短进程只用较少的时间就可完成(SPF的优点) ;不必实现估计进程的运行时间(避免用户作假);可灵活地调整对各类进程的偏好程度,比如CPU密集型进程、1/0密集型进程(拓展:可以将因1/0而阻塞的进程重新放回原队列,这样1/0型进程就可以保持较高优先级)

**饥饿**：会导致饥饿



![image-20220530163801196](https://s2.loli.net/2022/05/30/4ArMuXh3TiqfOkV.png)



设置多级就绪队列各级队列优先级丛高到低，时间片从小到大

新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片。若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经在最下级的队列，则重新放回最下级队列队尾

只有第k级队列为空时，才会为k+1级队头的进程分配时间片

被抢占处理机的进程重新放回原队列队尾



![image-20220530164122481](C:\Users\AiYou_\AppData\Roaming\Typora\typora-user-images\image-20220530164122481.png)





















## 2.3 同步与互斥





### 2.3.1 进程同步与进程互斥



#### 进程同步

同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调他们的工作次序而产生的制约关系

有的进程之间需要配合的完成工作，各进程的工作推进需要遵循一定的先后顺序





#### 进程互斥

对临界资源的访问，需要互斥的进行，同一时段只能允许一个进程访问该资源



进程互斥分为**四个部分**：

![image-20220530165552536](https://s2.loli.net/2022/05/30/przqCDOFG5RcXyo.png)

临界区是进程中访问临界资源的代码段

进入区和退出区是负责实现互斥的代码段



进程互斥需要**遵循的原则**：

- 空闲让进：临界区空闲时，应允许一个进程访问
- 忙则等待：临界区正在被访问时，其他试图访问的进程需要等待
- 有限等待：要在有闲时间内进入临界区，保证不会被饥饿
- 让权等待：进不了临界区的进程，需要释放处理机











### 2.3.2 进程互斥的软件实现方法



#### 单标志法

算法思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予

![image-20220601113126311](https://s2.loli.net/2022/06/01/LqxT9Ry6We3cniD.png)

缺点：轮流访问带来的问题是，如果此时允许进入临界区的进程是P0,而P0一直不访问临界区，则临界区空闲，但不允许P1访问。

**违背“空闲让进”原则**







#### 双标志先检查法

算法思想：设置一个布尔型数组flag[]，数组中各个元素用来标记各进程想进入临界区的意愿。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区,如果没有,则把自身对应的标志flag[i]设为true,之后开始访问临界区。

![image-20220601113546651](https://s2.loli.net/2022/06/01/zpAENZlbSGxW8yg.png)

若按照①⑤②⑥③⑦的顺序执行，P0和P1将会同时访问临界区。

因此，双标志先检香法的主要间颗是：违反“**忙则等待**”原则。

原因在于，**进入区的“检查”和“上锁”两个处理不是一气呵成**的。“检查”后，“上锁”前可能发生进程切换。









#### 双标志后检查法

算法思想：先上锁后检查

![image-20220601113802687](https://s2.loli.net/2022/06/01/lUHut5cavK7TCkW.png)

若按照①⑤②⑥.的顺序执行，P0和P1将都无法进入临界区

因此，双标志后检查法虽然解决了“忙则等待”的问题，但是又违背了**“空闲让进”和“有限等待”**原则，会因各进程都长期无法访问临界资源而产生饥饿。









#### Peterson算法

算法思想：孔融让梨，当双方都争着想进入临界区时，可以主动让对方使用临界区

![image-20220601114641319](https://s2.loli.net/2022/06/01/Ogid9xnzDJFlCqs.png)

进入区:
1.主动争取 
2.主动谦让:
3.检查对方是否也想使用,且最后一次是不是自己说了“客气话”

遵循了**空闲让进，忙则等待，有限等待**，**未遵循让权等待**













### 2.3.3 进程互斥的硬件实现方法





#### 中断屏蔽方法

利用“开关中断指令”实现

![image-20220601115633363](https://s2.loli.net/2022/06/01/GbBTOHtxm7P98Ao.png)

缺点：不适用于多处理机，只能用于操作系统内核进程







#### TestAndSet指令

TSL指令是用硬件实现的，执行过程中不允许被中断，只能一气呵成

![image-20220601115920669](https://s2.loli.net/2022/06/01/R2wdtOVrEmKzGkP.png)

若刚开始lock是false,则TSL返回的old值为false,while循环条件不满足，直接跳过循环，进入临界区。

若刚开始lock是true,则执行TSL后old返回的值为true,while循环条件满足，会一直循环，直到当前访问临界区的讲程在退出区讲行“解锁”

缺点：不满足**让权等待**，无法进入临界区的进程会占用CPU并循环执行TSL指令







#### SWAP指令

逻辑上与TSL指令区别不大

![image-20220601120248887](https://s2.loli.net/2022/06/01/1tSYxTmokMfCV37.png)

先记录下此时临界区是否已经被上锁（记录在old变量上)，再将上锁标记lock设置为true,最后检查old,如果old为false，则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。

缺点：不满足**让权等待**

![image-20220601120649697](https://s2.loli.net/2022/06/01/ov2BAuUOWVZTsLb.png)









### 2.3.4 信号量机制



使用信号量来表示系统中某种资源的数量

一对原语：wait(S)和signal(S),括号里的代表信号量，简称P，V操作



#### 整型信号量

用一个整数型的变量来作为信号量，用来表示系统中某种资源的数量

![image-20220601151915204](https://s2.loli.net/2022/06/01/nKDBekOG2Wo5XbT.png)

![image-20220601151936874](https://s2.loli.net/2022/06/01/eoB7gM61l8uq5xc.png)

缺点：仍然存在**让权等待**







#### 记录型信号量

用记录型数据结构表示信号量

![image-20220601152123569](https://s2.loli.net/2022/06/01/NWeADbKGOI9nahu.png)

    在考研题目中wait(S、signal(s)也可以记为

P(S)、V(S),这对原语可用于实现系统资源的“申请”和“释放”

S.value的初值表示系统中某种资源的数目。

对信号量S的**一次P操作意味着进程请求一个单位的该类资源**，因此需要执行S.value--, 表示资源数减1，当S.value<0时表示该类资源已分配完毕，因此进程应调用**block原语进行自我阻塞**（当前运行的进程从运行态→阻塞态)，主动放弃处理机，并插入该类资源的等待队列S.L中。可见，该机制**遵循了“让权等待”原则，不会出现“忙等”现象。**

对信号量S的**一次V操作意味着进程释放一个单位的该类资源**，因此需要执行S.value++,表示资源数加1，**若加1后仍是S.value<=0,表示依然有进程在等待该类资源**，因此应调用**wakeup原语唤醒等待队列中的第一个进程**（被唤醒进程从阻塞态→就绪态）。

![image-20220601152915185](https://s2.loli.net/2022/06/01/YEwcfo7Gy1kBdDb.png)















### 2.3.5 用信号量机制实现进程互斥，同步，前驱关系





#### 实现进程互斥

设置互斥信号量mutex，初值为1

在临界区之前执行P(mutex)

在临界区之后执行V(mutex)

![image-20220601213543141](https://s2.loli.net/2022/06/01/V1E6F3aNr7Uxqbe.png)









#### 实现进程同步

进程同步：要让各并发进程按照要求有序的推进



设置互斥信号量S，初值为0

在前操作之后执行V(S)

在后操作之前执行P(S)

![image-20220601214222511](https://s2.loli.net/2022/06/01/HlxDq9udSbh2GYA.png)







#### 实现前驱关系

![image-20220601214544987](https://s2.loli.net/2022/06/01/hXdcFDalrJbf9Uq.png)



![image-20220601214647592](https://s2.loli.net/2022/06/01/Dc2TOdtQ86hIAjG.png)











### 2.3.6 生产者消费者问题

问题描述：

系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。（注：这里的“产品理解为苯种数坛生产者、消费者共享一个初始为空、大小为的缓冲区。
只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。
只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。
缓冲区是临界资源，各进程必须互斥地访问



分析：

同步关系：

- 缓冲区满时，生产者必须等消费者取出后才能继续生产
- 缓冲区空时，消费者必须等生产者生产才能取出

互斥关系：

- 生产者和消费者必须互斥访问缓冲区



```c++
//初始化信号量
int mutex=1;
int buf=5;
int object=0;

Producer()
{
    p(buf);
    p(mutex);
    把产品放入缓冲区;
    v(mutex);
    v(object);
}

Consumer()
{
	p(object);
    p(mutex);
    把产品取出缓冲区;
    v(mutex);
    v(buf);
}
```

**实现互斥的P操作一定要在实现同步的P操作之后**，否则会造成死锁

![image-20220601215951195](https://s2.loli.net/2022/06/01/QBKv641ridV79LT.png)

生产者执行1，再执行2，由于没有缓冲区，生产者阻塞。此时切换消费者进程，无法访问临界资源。最终导致死锁。









### 2.3.7 多生产者-多消费者

​	桌子上有一只盘子,每次只能向其中放入一个水果。爸爸专向盘子中放苹果,妈妈专向盘子中放橘子,儿子专等着吃盘子中的橘子,女儿专等着吃盘子中的苹果。只有盘子空时,爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时,儿子或女儿可以从盘子中取出水果。
​	用PV操作实现上述过程。

![image-20220601220238314](https://s2.loli.net/2022/06/01/N7PZxAco5qOpvzV.png)



进程同步：

- 爸爸放苹果，女儿才会吃
- 妈妈放桔子，儿子才会吃
- 盘子空了，爸爸妈妈才会放水果；女儿和儿子可以把盘子清空

进程互斥：

- 盘子为临界资源



```c++
int apple=0;
int orange=0;
int plate=0;
int mutex=1;

father()
{
    p(plate);
    p(mutex);
    放苹果;
    v(mutex);
    v(apple);
}

mother()
{
    p(plate);
    p(mutex);
    放桔子;
    v(mutex);
    v(orange);
}

daughter()
{
    p(apple);
    p(mutex);
    取苹果;
    v(mutex);
    v(plate);
}

son()
{
    p(orange);
    p(mutex);
    取苹果;
    v(mutex);
    v(plate);
}
```











### 2.3.8 吸烟者问题

​	假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复（让三个抽烟者轮流地抽烟）

解析：

进程同步：

- 抽烟者拥有自己的原材料才可以抽烟
- 供应者只有在抽烟者抽完烟才可以继续供应

进程互斥：

- 桌子是临界资源



```c++
int offer1=0;
int offer2=0;
int offer3=0;
int finish=0;
int table=1;

producer()
{
        if(i==0)
        	V(offer1);
        else if(i==1)
            V(offer2);
        else if(i==2)
            V(offer3);
        i=(i+1)%3;
		p(finish);
}

smoker1()
{
    p(offer1);
    v(finish);
}

smoker2()
{
    p(offer1);
    v(finish);
}

smoker3()
{
    p(offer3);
    v(finish);
}
```









### 2.3.9 读者-写者问题

​	有读者和写者两组并发进程,共享一个文件,当两个或两个以上的读进程同时访问共享数据时不会产生副作用,但若某个写进程和其他进程(读进程或写进程)同时访问共享数据时则可能导致数据不一致的错误。因此要求: ①允许多个读者可以同时对文件执行读操作; ②只允许一个写者往文件中写信息;③任一写者在完成写操作之前不允许其他读者或写者工作; ④写者执行写操作前,应让已有的读者和写者全部退出。

互斥关系：写进程-读进程，写进程-写进程

写进程与任何进程都互斥，读进程与读进程不互斥

设置互斥信号量rw，写进程访问文件时对rw进行处理，读进程首次访问文件时对rw进行处理

使用count记录当前有几个读进程在访问文件

若没有mutex互斥变量，当两个读进程并发时，有可能会同时P(rw)，导致阻塞

```c++
semaphore rw=1;	//用于实现对文件的互斥访问。表示当前是否有进程在访问共享文件
int count=0;	//记录当前有几个进程在访问文件
semaphore mutex=1;//保证对count变量的互斥访问

writer()
{
    P(rw);
    写文件;
    V(rw);
}

reader()
{
    P(mutex);
    if(count==0)
        P(rw);
    count++;
    V(mutex);
    读文件;
    P(mutex);
    count--;
    if(count==0)
        V(rw);
    V(mutex);
}
```

缺点：如果一直有读进程在读，写进程就会一直阻塞等待，可能被饿死



增加一个 互斥信号量来实现写优先

```c++
semaphore rw=1;	//用于实现对文件的互斥访问。表示当前是否有进程在访问共享文件
int count=0;	//记录当前有几个进程在访问文件
semaphore mutex=1;//保证对count变量的互斥访问
semaphore w=1;	//实现写优先

writer()
{
    P(w);
    P(rw);
    写文件;
    V(rw);
    R(w);
}

reader()
{
    P(w);
    P(mutex);
    if(count==0)
        P(rw);
    count++;
    V(mutex);
    V(w);
    读文件;
    P(mutex);
    count--;
    if(count==0)
        V(rw);
    V(mutex);
}
```



​	读者写者问题为我们解决复杂的互斥问题提供了一个参考思路。

​	其核心思想在于设置了一个计数器cout用来记录当前正在访问共享文件的读进程数。我们可以用cout的值来判断当前进入的进程是否是第一个/最后一个读进程，从而做出不同的处理。

​	另外，对cout变量的检查和赋值不能一气呵成导致了一些错误，如果需要实现“一气呵成”，自然应该想到用互斥信号量。

​	最后，还要认真体会我们是如何解决“写进程饥饿”问题的。











### 2.3.10 哲学家进餐问题

​	一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子己在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。

​	每个哲学家进程需要同时持有两个临界资源才能吃饭。

​	每个哲学家都同时拿左且拿右时，并且并发执行，会导致死锁。

**防止死锁发生的方法**

- 最多只允许四个哲学家进餐
- 要求奇数号哲学家先拿左边的筷子，偶数号哲学家先拿右边的筷子，这样当两个相邻哲学家想吃饭时，可以保证不发生死锁
- 仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子

```c++
semaphore chopstick[5]={1,1,1,1,1};
semaphore mutex=1;
pi()
{
    P(mutex);
    P(chopstick[i]);
    P(chopstick[i+1]%5);
    V(mutex);
    吃饭;
    V(chopstick[i]);
    V(chopstick[i+1]%5);
}
```









### 2.3.11 管程



管程是一种特殊的软件模块

**基本特征**：

- 局部于管程的数据只能被局部于管程的过程所访问
- 一个进程只有通过调用管程内的过程才能进入管程访问共享数据
- 每次仅允许一个进程在管程内执行某个内部过程

![image-20220604202646837](https://s2.loli.net/2022/06/04/tYIpWHZgPnLlrym.png)











## 2.4 死锁





### 2.4.1 死锁的概念



#### 死锁的概念

各进程互相等待对方手里的资源,导致各进程都阻塞,无法向前推进



死锁:至少是两个进程一起死锁,死锁进程处于阻塞态

饥饿:可以只有一个进程饥饿,饥饿进程可能阻塞也可能就绪

死循环:可能只有一个进程发生死循环,死循环的进程可上处理机

死锁和饥饿是操作系统要解决的问题,死循环是应用程序员要解决的



#### 死锁产生的必要条件

**互斥条件**：对必须互斥使用的资源的争抢才会导致死锁

**不剥夺条件**：进程保持的资源只能主动释放，不可强行剥夺

**请求和保持条件**：保持着某些资源不放的同时，请求别的资源

**循环等待条件**：存在一种进程资源的循环等待链；循环等待未必死锁，死锁一定有循环等待





#### **死锁的处理策略**

**预防死锁**：破坏死锁产生的四个必要条件

**避免死锁**：避免系统进入不安全状态（银行家算法）

**死锁的检测和解除**：允许死锁发生，系统负责检测出死锁并解除









### 2.4.2 死锁的处理策略--预防死锁



#### **破坏互斥条件**

采用spooling技术把独占设备在逻辑上改造成共享设备



#### 破坏不可剥夺条件

方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所右盗酒待以后需要时再重新申请。也就是说，即便某些资源尚未便用完，也需要主动释放，从而破坏了不可剥夺条件。

方案二：当某个进程需要的资源被其他讲积所占右的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级（比如：剥夺调度万式，就是将处理机资源强行剥夺给优先级更高的进程使用)



#### 破坏请求和保持条件

可以采用静态分配方法,即进程在运行前一次申请完它所需要的全部资源,在它的资源未满足前,不让它投入运行。一旦投入运行后,这些资源就一直归它所有,该进程就不会再请求别的任何资源了。

缺点：资源利用率低，可能导致某些进程饥饿



#### 破坏循环等待条件

可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完。

一个进程只有占有小编号资源时，才有资格申请更大编号的资源

在任何一个时刻，总右个讲程拥有资源编号是最大的，那这个进程申请之后的资源必然畅通无阻。
因此，不可能出现所有进程都阻塞的死锁现象









### 2.4.3 死锁的处理策略--处理死锁



**安全序列**,就是指如果系统按照这种序列分配资源,则每个进程都能顺利完成。只要能找出一个安全序列,系统就是安全状念。当然,安全序列可能有多个。

如果系统分配了资源之后，系统中找不到任何一个安全序列，系统就进入了一个不安全状态

**在资源分配之前预先判断这次分配是否会导致系统进入不安全状态**，以此决定是否答应资源的分配请求，此法为银行家算法。



#### 银行家算法

![image-20220606163732329](https://s2.loli.net/2022/06/06/sTXHbuBC4rKE3iL.png)



银行家算法步骤:

①检查此次申请是否超过了之前声明的最大需求数

②检查此时系统剩余的可用资源是否还能满足这次请求

③试探着分配,更改各数据结构

④用安全性算法检查此次分配是否会导致系统进入不安全状态



系统处于不安全状态未必死锁,但死锁时一定处于不安全状态。系统处于安全状态一定不会死锁。











### 2.4.4 死锁的处理策略--检测和解除



#### 死锁的检测

![image-20220606164346366](https://s2.loli.net/2022/06/06/5RhB2SFxAObNnUW.png)

进程结点:对应一个进程

资源结点:对应一类资源,一类资源可能有多个

进程结点->资源结点:表示进程想申请几个资源(每条边代表一个)

资源节点->进程结点:表示已经为进程分配了几个资源(每条边代表一个)





#### 死锁的解除

1,资源剥夺法。挂起(暂时放到外存上)某些死锁进程,并抢占它的资源,将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。

2,撤销进程法(或称终止进程法)。强制撤销部分、甚至全部死锁进程,并剥夺这些进程的资源。这种万式的优点是买现简单,但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间,已经接近结束了,一旦被终止可谓功亏一簧,以后还得从头再来。

3.进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步,这就要求系统要记录进程的历史信息,设置还原点。













# 3. 内存的管理













## 3.1 内存管理概念











### 3.1.1 内存的基础知识





#### 什么是内存？有何作用？

内存是用于存放数据的硬件，程序执行前需要先放到内存中才能被cpu处理





内存地址从0开始，每个地址对应一个存储单元

按字节编址，每个存储单元大小为1字节，即8位

按字编址，每个存储单元大小为1个字，每个字的大小取决于字长，32位系统或者64位系统

![image-20220607150636836](https://s2.loli.net/2022/06/07/aCENQhpZsK89B15.png)





指令的运行原理：{指令，目标地址，初始地址}

相对地址又称逻辑地址，绝对地址又称物理地址



从写程序到运行：预处理，编译，汇编，链接，装入

![image-20220607150950002](https://s2.loli.net/2022/06/07/GXfYUwTBemaN14V.png)





#### 装入的三种方式（逻辑地址到物理地址的转换）



- **绝对装入**

在编译时，编译程序将产生绝对地址的目标代码，装入程序按照装入模块的地址，将程序和数据装入内存

绝对装入只适用于**单道程序环境**

- **静态重定位**

装入时对地址进行“重定位”，将逻辑地址变换为物理地址。

例如装入的起始物理地址为100，则所有地址相关都+100

特点：    是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装人该业。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间。

- **动态重定位**

装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才装入。

重定位寄存器:存放装入模块存放的起始位置

并且可将程序分配到不连续的存储区中：在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态中请分配内存：便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间

特点：需要重定位寄存器支持，允许在程序在内存中发生移动











#### 链接的三种方式

链接的三种方式:

1.静态链接:在程序运行之前,先将各目标模块及它们所需的库函数连接成一个完整的可执行文件(装入模块) ,之后不再拆开。

2.装入时动态链接:将各目标模块装入内存时,边装入边链接的链接方式。

3.运行时动态链接:在程序执行中需要该目标模块时,才对它进行链接。其优点是便于修改和更新,便于实现对目标模块的共享。







### 3.1.2 内存管理的概念

1.操作系统负责**内存空间的分配与回收**

2.操作系统需要提供某种技术**从逻辑上对内存空间进行扩充**

3.操作系统需要提供地址**转换功能**,**负责程序的逻辑地址与物理地址的转换**

4,操作系统需要提供内存**保护功能**。**保证各进程在各自存储空间内,运行,互不干扰**

- 法一：设置上下限寄存器，存放进程的上下限地址，判断是否越界
- 法二：采用重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器），重定位寄存存放的是起始物理位置，界地址寄存器存放的是最大逻辑地址。











### 3.1.3 覆盖与交换

内存管理：从逻辑上对内存空间进行扩充



#### 覆盖

覆盖技术：将程序分为多个段。

常用的段常驻内存，不常用的段在需要时调入内存内存中分为**一个“固定区”**和**若干个“覆盖区”**

需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束）

不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出丙存





#### 交换

交换(对换)技术的设计思想:内存空间紧张时,系统**将内存中某些进程暂时换出外存**,**把外存中某些已具备运行条件的进程换入内存(**进程在内存与磁盘间动态调度)

1.应该在外存（磁盘）的什么位置保存被换出的进程？

2.什么时候应该交换？

3.应该换出哪些进程？

1.具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配万式：对换区空间只古磁盆盘空间的小部分，被换出的进程数据就存放在对预区。由于对换的速度按影呵到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式（学过文件管理章节后即可理解)。总之，对换区的1/O速度比文件区的更快。

2.交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程：如果缺页率明显下降，就可以暂停换出。

3.可优先换出阻塞进程：可换出优先级低的进程：为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间(注意：PCB会常驻内存，不会被换出外存)





#### 覆盖与交换的区别

覆盖是在同一个程序或进程中的

交换是不同进程或作业之间的













### 3.1.4 连续分配管理方式

负责内存空间的分配与回收：为用户进程分配的必须是一个连续的内存空间



#### 单一连续分配

内存被分为系统区和用户区

内存中只有一道用户程序，独占整个用户区空间





#### 固定分区分配

将用户空间分为若干个固定大小的分区，在每个分区中只装入一道作业

分区大小可以相等可以不等

**分区说明表**：包括对应分区的大小，起始地址，状态

![image-20220608160904513](https://s2.loli.net/2022/06/08/mTvhM7Cki4pcl65.png)

![image-20220608160916108](https://s2.loli.net/2022/06/08/iBVSEfdUI8L9XMt.png)

优点：

缺点：





#### 动态分区分配

​	动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。(eg:假设某计算机内存大小为64MB,系统区8MB,用户区共56MB.)

![image-20220608161104017](https://s2.loli.net/2022/06/08/YNskS54R3VGJlWt.png)

动态分区分配没有内部碎片，但是有外部碎片。

**内部碎片**，分配给某进程的内存区域中，如果有些部分没有用上。

**外部碎片**，是指内存中的某些空闲分区由于太小而难以利用。

可以通过**紧凑技术**来解决外部碎片







### 3.1.5 动态分区分配算法



#### 首次适应法

​	算法思想:每次都从低地址开始查找,找到第一个能满足大小的空闲分区。

​	如何实现:空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链(或空闲分区表),找到大小能满足要求的第一个空闲分区。





#### 最佳适应算法

​	算法思想:由于动态分区分配是一种连续分配方式,为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间,可以尽可能多地留下大片的空闲区,即,优先使用更小的空闲区。

​	如何实现:空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区,表),找到大小能两定要求的第一个空闲分区。

​	缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片。





#### 最大适应算法

​	又称最坏适应算法(Largest Fit)算法思想：为了解决最佳适应算法的问题――即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。

​	如何实现：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。





#### 邻近适应算法

​	每次都从上次查找结束的位置开始检索

​	如何实现：空闲分区以地址递增的顺序排列（可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。





![image-20220610211940990](https://s2.loli.net/2022/06/10/fJDBKpdPUSzN2ck.png)











### 3.1.6 基本分页式存储管理的基本概念



#### 连续分配方式的缺点

考虑支持多道程序的两种连续分配方式：

1.固定分区分配：缺乏灵活性，会产生大量的内部碎片，内存的利用率很低。

2.动态分区分配：会产生很多外部碎片，虽然可以用“紧凑”技术来处理，但是“紧凑”的时间代价很高



**基本分页存储管理的思想**--把内存分为一个个相等的小分区，再按照分区大小把进程拆分成一个个小部分

每个分区就是一个**页框**（**页帧，内存块，物理块**）

每个页框有一个编号,即**“页框号”**(或者**“内存块号”、“页帧号”、“物理块号”)**页框号从0开始。

操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一一对应的关系。

各个页面不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中。

![image-20220610212658693](https://s2.loli.net/2022/06/10/WLiR1jwuY5M4QdV.png)

#### 地址转换

**连续存放**：地址转换是由“起始地址”+目标内存单元相对于起始位置的“偏移量“

**分页技术**：

1.要算出逻辑地址对应的**页号**

2.要知道该**页号对应页面在内存中的起始地址**

3.要算出逻辑地址**在页面内的“偏移量”**

4.**物理地址=页面始址+页内偏移量**

![image-20220610212956419](https://s2.loli.net/2022/06/10/VUbdlCI3ZS4esRt.png)

**页号**=逻辑地址/页面长度

**页内偏移量**=逻辑地址%页面长度

页面在内存中的**起始位置**：操作系统需要用某种数据结构记录进程各个页面的起始位置。





为了方便计算页号、页内偏移量，页面大小一般要为2的整数幂

假设用32个二进制位表示逻辑地址,页面大小为2^12B =4096B =4KB



0号页的逻辑地址空间应该是0～4095，用二进制表示应该是：

00000000000000000000<u>000000000000</u>~0000000000000000000<u>1111111111111</u>

1号页的逻辑地址空间应该是4096～8191，用二进制表示应该是：

00000000000000000001<u>000000000000</u>~0000000000000000001<u>1111111111111</u>

结论：如果每个页面大小为2KB, 用二进制数表示逻辑地址，则**末尾K位即为页内偏移量**，其余部分就是**页号**













#### 逻辑地址结构

分页存储管理的逻辑地址结构如下所示：

![image-20220610214013409](https://s2.loli.net/2022/06/10/RmAn1e74wX3GPY2.png)











#### 页表

为了能知道进程的每个页面在内存中存放的位置，操作系统要为**每个进程建立一张页表**。

![image-20220610214324991](https://s2.loli.net/2022/06/10/aWkYZhicT5V1Qer.png)

​	Eg:假设某系统物理内存大小为4GB,页面大小为4KB,则每个页表项至少应该为多少字节？

​	4GB=2^32B,4KB=2^12B。

​	 因此4GB的内存总共会被分为2^32/2^12=220个内存块，因此内存块号的范围应该是0~2^20-1

​	因此至少要20个二进制位才能表示这么多的内存地号，因此至少要3个字节才够(每个字节8个二进制位，3个字节共24个二进制位)



![image-20220610214916750](https://s2.loli.net/2022/06/10/tfizwVAb4OTGRqo.png)









### 3.1.7 基本地址变换机构

​	通常会在系统中设置一个**页表寄存器(PTR)** ,存放页表在内存中的**起始地址F**和**页表长度M**。

​	进程未执行时,**页表的始址和页表长度放在进程控制块(PCB)**中,当进程被调度时,操作系统内核会把它们放到页表寄存器中。



![image-20220610223839418](https://s2.loli.net/2022/06/10/VQqXwjglzCnv3Ki.png)



**页表长度**指的是这个页面共有几个页表项，总共有几页

**页表项长度**指的是每个页表项占多大空间

**页面大小**指的是一个页面占的空间



![image-20220610224934176](https://s2.loli.net/2022/06/10/xLgFIUvpkrRobXs.png)















### 3.1.8 具有快表的地址变换机构



**时间局部性**:如果执行了程序中的某条指令,那么不久后这条指令很有可能再次执行;如果某个数据被访问过,不久之后该数据很可能再次被访问。(因为程序中存在大量的循环)

**空间局部性**:一旦程序访问了某个存储单元,在不久之后,其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的)



**快表，又称联想寄存器（TLB）**，是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访向的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为慢表。

![image-20220611102842222](https://s2.loli.net/2022/06/11/2acrhP1To5g6FYX.png)

①CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。

②如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需**一次访存**即可。

③如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表未命中，则访问某个逻辑地址需要**两次访存**（注意：在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换)



![image-20220611103218481](https://s2.loli.net/2022/06/11/Ei8Y9oIeR4vx1Ba.png)







### 3.1.9 两级页表



#### 单级页表存在的问题

支持32位的逻辑地址，页面大小为4KB，页表项长度为4B。

4kb=2^12B，需要12位表示页内地址，20位表示页号，用户进程最多有2^20个页表项，最需要2^20*4B=2^22B，需要2^22/2^12=2^10个页框来存储页表

并且所有页表项都需要连续存储，当页表很大时，需要占据很多连续的页框





#### 两级页表原理、地址结构



建立页目录表，来记录各个离散页表的位置

![image-20220611104420923](https://s2.loli.net/2022/06/11/CpHQ9gxotVyAMEi.png)





![image-20220611104522484](https://s2.loli.net/2022/06/11/LIelmVPWRgNvCKA.png)





问题二：没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。

可以在需要访问页面时才把页面调入内存（虚拟存储技术）。可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存

若想访问的页面不在内存中，则产生缺页中断（内中断），然后将目标页面从外存调入内存



#### 细节

多级页表中，**各级页表的大小不能超过一个页面**。若两级页表不够，可以分更多级多级（页面大小为4KB,页表项大小为4B，最多放2^10个页表项）

页表的访存次数（假设没有快表机构）-**N**级页表访问一个逻辑地址需要**N＋1**次访存





### 3.1.10 基本分段存储管理方式



​	进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名（在低级语言中，程序员使用段名来编程）,每段从0开始编址

​	内存分配规则：以段为单位进行分配，**每个段在内存中占据连续空间**，但各**段之间可以不相邻**。



![image-20220613162258933](https://s2.loli.net/2022/06/13/pzoRCrnwLFNVlgG.png)



​	分段系统的逻辑地址结构由段号(段名)和段内地址(段内偏移量)所组成。如:

![image-20220613162544992](https://s2.loli.net/2022/06/13/JGbDRn5UktrjqCh.png)

**段号的位数决定了每个进程最多可以分几个段**

**段内地址位数决定了每个段的最大长度是多少**





#### 段表

![image-20220613162819515](https://s2.loli.net/2022/06/13/WP2bSL6qUZRyjMF.png)





![image-20220613162924722](https://s2.loli.net/2022/06/13/gIxAnSYlKFD2GWT.png)



![image-20220613163145653](https://s2.loli.net/2022/06/13/kPXGC7gpvDuqfU1.png)





#### 分段和分页管理的对比



**页是信息的物理单位。**分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，**对用户是不可见的。**

**段是信息的逻辑单位。**分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。**分段对用户是可见的**，用户编程时需要显式地给出段名。

页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。

**分页的用户进程地址空间是一维的**，程序员只需给出一个记忆符即可表示一个地址。

**段的用户进程地址空间是二维的**，程序员在标识一个地址时，既要给出段名，也要给出段内地址。

**分段比分页更容易实现信息的共享和保护。**

访问一个逻辑地址需要几次访存？

分页（单级页表）：第一次访存一—查内存中的页表，第二次访存——访问目标内存单元。总共两次迈存

分段：第一次访在——查内存中的段表，第二次访存——访问目标内存单元。总共两次访存

与分页系统类似，分段系统中也可以引入快表机构，将近期访问过的段表项放到快表中，这样可以少一次访问，加快地址变换速度。













### 3.1.11 段页式管理方式



#### 分页分段的优缺点分析

![image-20220613164804609](https://s2.loli.net/2022/06/13/EBYJ9F2Vg1d6tOX.png)



#### 段页式管理

![image-20220613164842121](https://s2.loli.net/2022/06/13/YAvStjwUmfRIL42.png)



段页式系统的逻辑地址结构由**段号**、**页号**、**页内地址（页内偏移量）**组成。如：

![image-20220613165201783](https://s2.loli.net/2022/06/13/eaZsPjwMgDySOrc.png)

**段号的位数决定了每个进程最多可以分几个段页**

**号位数决定了每个段最大有多少页**

**页内偏移量决定了页面大小、内存块大小是多少**



![image-20220613165401026](https://s2.loli.net/2022/06/13/GUgRZaPAuHvBxSz.png)

![image-20220613165523368](https://s2.loli.net/2022/06/13/bvKRrQwjdBDWoP2.png)









## 3.2 虚拟内存管理



### 3.2.1 虚拟内存的概念



#### 1. 传统存储管理方式的特征和缺点

一次性：作业必须一次性全部装入内存后才可以运行

驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束





#### 2. 局部性原理

**时间局部性**：如果执行了程序中的某条指令，那么不久后这条指今很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）

**空间局部性**：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。
（因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）

![image-20220613170723029](https://s2.loli.net/2022/06/13/UqzYuCQ7RgfLmEl.png)

**高速缓冲技术的思想：**

将近期会频繁访问到的数据放到更高速的存储照中，暂时用不到的数据放在更低速存储器中。







#### 3. 虚拟内存的定义和特征

基于局部性原理，在程序装入时，可以**将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存**，就可以让程序开始执行。

在程序执行过程中，**当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存**，然后继续执行程序。

若内存空间不够，由**操作系统负责将内存中暂时用不到的信息换出到外存**。



虚拟内存的**最大容量**是由计算机的地址结构（CPU寻址范围）确定的

虚拟内存的**实际容量**＝min（内存和外存容量之和，CPU寻址范围）

如：某计算机地址结构为32位，按字节编址，内存大小为512MB，外存大小为2GB。
则虚拟内存的最大容量为232B＝4GB 虚拟内存的实际容量＝min（232B，512MB＋2GB）＝2GB＋512MB



虚拟内存有一下三个主要特征：

**多次性**：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。

**对换性**：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。

**虚拟性**：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。



虚拟内存的实现需要建立在**离散分配**的内存管理方式基础上。

![image-20220613185736562](https://s2.loli.net/2022/06/13/L95zBWMxwZr6POt.png)

![image-20220613185744751](https://s2.loli.net/2022/06/13/f6re2ciPWCs3ADN.png)

操作系统提供，**请求调页（请求调段）功能**以及**页面置换（段置换）**的功能

















### 3.2.2 请求分页管理方式



​	**请求分页存储管理**与**基本分页存储管理**的主要区别：

​	在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序

​	若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存





#### 页表机制



![image-20220616153100140](https://s2.loli.net/2022/06/16/GI9fUM3Kr6HJ5NS.png)



#### 缺页中断

​	假设此时要访问逻辑地址＝（页号，页内偏移量）＝（0,1024）

​	在请求分页系统中，每当要访问的**页面不在内存**时，便产生一个**缺页中断**，然后由操作系统的**缺页中断处理程序处理中断**。

​	此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列

​	如果内存中有**空闲块**，则为**进程分配一个空闲块**，将所缺页面装入该块，并修改页表中相应的页表项。

​	如果内存中**没有空闲块**，则由**页面置换算法选择一个页面淘汰**，若该页面在内存期间被修改过，则要将其写回外存。未修改过的页面不用写回外存。



#### 地址变换

![image-20220616154331307](https://s2.loli.net/2022/06/16/O5EFNBwCQ7od8Zp.png)

​	只有“写指令”才需要修改“修改位”。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数

​	换入换出页面都需要启动慢速的I/O操作，可见，如果换入/换出太频繁，会有很大的开销。

​	页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中。











### 3.2.3 页面置换算法

页面的换入、换出需要磁盘I/O，会有较大的开销，因此好的页面置换算法应该追求更少的缺页率





#### 最佳置换算法

































# 4.文件管理







## 4.1 文件系统基础





### 4.1.1 初识文件管理



![image-20220616163025664](https://s2.loli.net/2022/06/16/s8nudhwL7bgV4N1.png)





### 4.1.2 文件的逻辑结构

逻辑结构：用户看来，文件内部的数据如何组织起来的



#### 无结构文件

无结构文件：文件内部的数据就是一系列二进制流或字符流组成。又称“流式文件”。



#### 有结构文件

每条记录由若干个数据项组成。每条记录有一个数据项作为关键字

分为**定长记录**和**可变长记录**



##### 顺序文件

顺序文件:文件中的记录一个接一个地顺序排列(逻辑上),记录可以是定长的或可变长的。各个记录在物理上可以顺序存储或链式存储。

![image-20220616163944959](https://s2.loli.net/2022/06/16/4FCmfNhbIonBvgd.png)

![image-20220616164032657](https://s2.loli.net/2022/06/16/LGCzMseo3Am8O2N.png)

顺序存储的缺点是增加删除一个记录比较困难（串结构相对简单）







##### 索引文件

索引可以对可变长文件进行随机存取

索引表本身就是定长记录的顺序文件

若索引表按关键字顺序排列，则支持快速检索

![image-20220616164309493](https://s2.loli.net/2022/06/16/JXz4WOto3IBbp8m.png)





##### 索引顺序文件

索引文件的缺点：索引表可能会很大

索引顺序文件将**一组记录**对应一个索引表

![image-20220616164645138](https://s2.loli.net/2022/06/16/QpxOsYwdNMKRjt6.png)



假设顺序文件有10000个记录，采用索引文件，平均需查找5000个记录

采用顺序索引文件，将10000个记录分为100组，每组100个记录，平均需要查找50+50次





##### 多级索引顺序文件

建立多级索引表

![image-20220616164951920](https://s2.loli.net/2022/06/16/WtEdfpGNYniC6Io.png)

Tips：要为N个记录的文件建立K级索引，则最优的分组是每组N^ 1／（K＋1）个记录。

检索一个记录的平均查找次数是（（N^1／（K＋1））／2）＊（K＋1）

如：本例中，建立2级索引，则最优分组为每组100000^1／3＝100个记录，平均查找次数是（100／2）＊3＝150次













### 4.1.3 文件目录



#### 文件控制块

目录本身就是一种有结构文件，由一条条记录组成。

目录文件中的一条记录就是一个“文件控制块（FCB）”

一个文件对应一个FCB, 一个FCB就是一个目录项,多个FCB组成文件目录

![image-20220616201010524](https://s2.loli.net/2022/06/16/ZB136a72kXSGbnd.png)



#### 目录结构



##### 单机目录结构

单机目录实现了“按名存取”，但是不允许文件重名

整个系统中只有一张目录表

（不适用于多用户操作系统）



##### 两级目录结构

**主文件目录**和**用户文件目录**

主文件目录记录用尸名及相应用户文件目录的存放位置

用户文件目录由该用户的文件FCB组成

两级目录允许不同用户的文件重名



##### 多级目录结构（树形目录结构）

用“/”隔开。从根目录出发的路径称为绝对路径。

例如：自拍.jpg的绝对路径是“/照片/2015-08/自拍.jpg"

从当前目录出发的“相对路径”

“./2015-08/自拍.jpg”



##### 无环图目录结构

​	可以用不同的文件名指向同一个文件,甚至可以指向同一个目录(共享同一目录下的所有内容)。

​	需要为每个共享结点设置一个共享计数器,用于记录此时有多少个地方在共享该结点。用户提出删除结点的请求时,只是删除该用户的FCB、并使共享计数器减1,并不会直接删除共享结点。

​	只有共享计数器减为0时,才删除结点。

​	注意:共享文件不同于复制文件。在共享文件中,由于各用户指向的是同一个文件,因此只要其中一个用户修改了文件数据,那么所有用户都可以看到文件数据的变化。







#### 索引节点



![image-20220616201245051](https://s2.loli.net/2022/06/16/1psVD4ExHOhJCeW.png)

​	当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件。

​	存放在外存中的索引结点称为“磁盘索引结点”，当索引结点放入内存后称为“内存索引结点”

​	相比之下内存索引结点中需要增加一些信息，比如：文件是否被修改、此时有几个进程正在访问该文件等。







### 4.1.4 文件的物理结构







