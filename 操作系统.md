# 1. 操作系统概述

















## 1.1操作系统的概念功能



### 操作系统的概念

- 负责管理协调硬件、软件等计算机资源的工作
- 为上层用户、应用程序提供简单易用的服务
- 是一种系统软件



### 操作系统的功能和目标

- 资源管理者
  - 处理机管理
  - 存储器管理
  - 文件管理
  - 设备管理
- 向上层提供服务
  - 给普通用户的
    - GUI界面
    - 命令接口
      - 联机命令接口
      - 脱机命令接口
  - 给程序员使用的
    - 程序接口
      - 系统调用
- 对硬件机器的扩展
  - 在裸机上安装的操作系统， 可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能 更强、使用更方便的机器













## 1.2 操作系统的特征







### 操作系统的四个特征





#### 1.并发（基本特征）

并发：指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的

并行：指两个或多个事件在同一时刻同时发生





#### 2.共享（基本特征）

- 互斥共享

​		一个时间段内只允 许一个进程访问该资源

- 同时共享

​		允许一个时间段 内由多个进程“同时”对它们进行访问

互斥共享方式：使用QQ和微信视频。同一时间段内摄像头只能分配给其中一个进程。 

同时共享方式：使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件， 说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。









#### 3.虚拟

虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。



虚拟技术中的“空分复用技术”。微观上内存在各个微小的时间段内交替 着为各个进程服务

虚拟技术中的“时分复用技术”。微观上处理机在各个微小的时间段内交替 着为各个进程服务







#### 4.异步

异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的， 而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。

如果失去了并发性，即系统只能串行地 运行各个程序，那么每个程序的执行会 一贯到底。只有系统拥有并发性，才有 可能导致异步性。





#### 各个特征之间的关系



并发和共享互为存在条件 

没有并发和共享，就谈不上虚拟和异步，

因此并发和共享是操作系统的两个最基本的特征





并发与共享的关系

使用QQ发送文件A，同时使用微信发送文件B。 

1、两个进程正在并发执行（并发性） 

2、需要共享地访问硬盘资源（共享性）









## 1.3 操作系统的发展和分类



### 1.手工操作阶段



### 2.批处理阶段



#### 单道批处理系统

​	引入脱机输入输出技术，内存中仅能 有一道程序运行，只有该程序运行结束之后才 能调入下一道程序。

​	优点：缓解人机交互速度

​	缺点：存中仅能 有一道程序运行，只有 该程序运行结束之后才 能调入下一道程序。 CPU有大量的时间是在 空闲等待I/O完成。





#### 多道批处理系统

​	优点：多道程序并发执行，共享计算机资源。

​	缺点：不提供人机交互







### 3.分时操作系统

​	计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互。

​	优点：用户请求可以被即时响应，解决了人机交互问题

​	缺点：不能优先处理一些紧急任务







### 4.实时操作系统

硬实时操作系统：要在严格的时限内处理完事件。

软实时操作系统：能接受偶尔违反时间规定









## 1.4 操作系统的运行机制与体系结构



### 运行机制

两种指令：特权指令和非特权指令

两种处理器状态：核心态（特权指令、非特权指令都可以执行）和用户态（cpu只执行非特权指令）

​	用程序状态字寄存器(PSW)中的某标志位来标识当前处理器处于什么状态。如0为用户态,1为核心态

两种程序：内核程序和应用程序



1,特权指令只能在核心态下执行

2.内核程序只能在核心态下执行



### 操作系统内核

内核是计算机上配置的底层软件，是操作系统最基本、最核心的部分。

实现操作系统内核功能的那些程序就是内核程序。

![image-20220524163713622](https://s2.loli.net/2022/05/24/YJQTjWwZ2copef3.png)

![image-20220524163610773](https://s2.loli.net/2022/05/24/V1nLk4JIUQdPrZx.png)







### 体系结构

![image-20220524163738319](https://s2.loli.net/2022/05/24/aXiMHEuj2AsyQ3x.png)













## 1.5 中断和异常



### 中断的概念和作用

1.当中断发生时，CPU立即进入核心态

2.当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理

3.对于不同的中断信号，会进行不同的处理



#### 用户态和核心态之间的切换

中断可以使CPU从用户态切换为核心态，使操作系统获得计算机的控制权

“用户态→核心态”是通过中断实现的。并且中断是唯一途径。

“核心态→用户态”的切换是通过执行一个特权指令,将程序状态字(PSW)的标志位设置为“用户态”





### 中断的分类

- 内中断（信号来源cpu内部）
  - 自愿中断：系统调用（陷入指令，trap指令）
  - 强迫中断：硬件故障（缺页），软件中断（除0）
- 外中断（信号来源cpu外部）
  - 外设请求
  - 人工干预





### 外中断处理过程

每条指令执行结束后, CPU检查是否有外部中断信号

若有外部中断信号,则需要保护被中断进程的CPU环境

根据中断信号类型转入相应的中断处理程序

恢复原进程的CPU环境并退出中断,返回原进程继续往下执行









## 1.6 系统调用



### 系统调用的概念

操作系统提供给应用程序的接口

应用程序通过系统调用请求获得操作系统的服务

系统调用可以使处理器从用户态进入核心态

![image-20220524165440498](https://s2.loli.net/2022/05/24/iX98WPdBZHCU1LQ.png)







### 系统调用和库函数的区别

系统调用是操作系统向上层提供接口

库函数是对系统调用的进一步封装

通过高级语言提供的库函数来间接的进行系统调用





### 系统调用的过程

1. 传递系统调用参数
2. 执行陷入指令
3. 执行系统调用相应服务程序
4. 返回用户程序

系统调用发生在用户态，对系统调用的处理发生在核心态















# 2. 进程与线程









## 2.1 进程与线程







### 2.1.1 进程的定义 组成 组织方式 特征



#### 进程的定义

- 进程就是一个指令序列
- **PCB**，**程序段，数据段**三部分构成了进程实体
- PCB（进程控制块），用来描述进程的各种信息
- **PCB是进程存在的唯一标志**
- 进程是进程实体的运行过程，是系统进行**资源分配**和**调度**的一个独立单位



#### 进程的组织

- 链接方式
  - 按照进程状态将PCB分为多个队列
  - 操作系统持有指向各个队列的指针

执行指针（当前处于运行态的进程）

就绪队列指针（处于就绪态的进程）

阻塞队列指针（处于阻塞态的进程）

指针指向的都是队列，优先级高的进程在队头



- 索引方式
  - 根据进程状态的不同，建立几张索引表
  - 操作系统持有指向各个索引表的指针

执行指针（当前处于运行态的进程）

就绪队列指针（处于就绪态的进程）

阻塞队列指针（处于阻塞态的进程）

指针指向的都是索引表



#### 进程的特征

动态性：最基本的特征

并发性

独立性：进程是资源分配，接受调度的基本单元

异步性

结构性

















### 2.1.2 进程的状态与转换



#### 进程的状态

运行状态：占用cpu

就绪状态：已具备运行条件，由于无空闲CPU，而不能运行

阻塞状态：因等待某事件而不能运行

创建状态：进程正在被创建，初始化PCB，分配资源

终止状态：撤销进程，撤销PCB,撤销资源







#### 进程之间的状态转换



![image-20220525160717476](https://s2.loli.net/2022/05/25/JBbvGghxdWZLVUe.png)











### 2.1.3 进程的控制



进程控制就是实现进程状态转换，即五个状态之间的转换



#### 实现进程控制

使用原语实现，这种不可以被中断的操作即原子操作

原语采用“关中断指令”和“开中断指令”实现

![image-20220525163128784](https://s2.loli.net/2022/05/25/GxALRa6Yd94wFDZ.png)

关/开中断指令的权限非常大,必然是只允许在核心态下执行的特权指令



进程控制需要完成的步骤

1.更新PCB中的信息(如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境)

​	a.所有的进程控制原语一定都会修改进程状态标志

​	b.剥夺当前运行进程的CPU使用权必然需要保存其运行环境

​	c.某进程开始运行前必然要恢复期运行环境

2.将PCB插入合适的队列

3.分配/回收资源









### 2.1.4 进程通信

进程通信就是进程之间的信息交换

进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的**内存地址空间相互独立**。

进程之间不能直接访问对方的地址空间

进程的通信分三种：

- 共享存储
- 消息传递
- 管道通信



#### 共享存储

![image-20220526153048418](https://s2.loli.net/2022/05/26/n3J6NLDs9Z54xzo.png)



#### 管道通信

![image-20220526153305868](https://s2.loli.net/2022/05/26/nt8oGW5Fh7deMOV.png)





#### 消息传递

![image-20220526153349861](https://s2.loli.net/2022/05/26/GebVajh7fEDldnU.png)



















### 2.1.5 线程概念与多线程模型

有的进程需要“同时”做很多事，而传统的进程只能串行的执行一些列程序，需要引入**线程**增加并发度

传统的进程是程序执行流的最小单位

引入线程后，**线程**成为了**程序执行流的最小单位**

**进程**作为出CPU外的**系统资源的分配单元**；**线程**作为**CPU的分配单元**

进程之间可以并发，进程内的各线程之间也可以并发



系统开销：

- 传统的进程间并发，需要切换进程的运行环境，系统开销很大
- 线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小
- 引入线程后，并发所带来的系统开销减小



![image-20220526154054998](https://s2.loli.net/2022/05/26/OjSIltWeMsbC61x.png)



#### 线程的实现方式

- 用户级线程

用户级线程由程序通过线程库实现，所有线程都由应用程序负责。线程的切换在用户态下即可完成。

在用户看来为多个线程，在操作系统内核看来，并意识不到线程的存在



- 内核级线程

内核级线程的管理工作由操作系统的内核完成，切换在核心态下完成

**内核级线程才是处理机分配的单元**







#### 多线程模型

由几个用户级线程映射到几个内核级线程的问题引出了“多线程模型”问题。



##### 多对一

多个用户级线程应设一个内核级线程

优：进程管理开销小效率高

缺：一个线程阻塞会导致整个进程都被阻塞(并发度低)



##### 一对一

一个用户级线程应设一个内核级线程

优：各个线程可分配到多核处理机并行执行，并发度高

缺：进程管理开销大



##### 多对多

多个用户级线程应设多个内核级线程

集二者之所长







## 2.2 处理机调度









### 2.2.1 处理机调度的概念、层次



- 高级调度（作业调度）

从外存上处于后备队列的作业中挑选一个或多个作业给他们分配内存资源，并建立相应的进程

高级调度是**外存**与**内存**之间的调度。高级调度主要指**调入**的问题



- 中间调度（内存调度）

将处于挂起状态的进程调入内存。

挂起状态：暂时调到外存等待的进程状态



- 低级调度（进程调度）

按照某种规则，从就绪队列中选择一个进程为其分配CPU



![image-20220530154124719](https://s2.loli.net/2022/05/30/L4Qikn2Hvohjdz6.png)

![image-20220527162625588](https://s2.loli.net/2022/05/27/YOK3sBndPpFlTqU.png)









### 2.2.2 进程调度的时机，切换过程，调度方式



#### 进程调度的时机

当前运行的进程主动放弃CPU:	进程正常终止，进程主动请求阻塞等等

当前运行的进程被动放弃CPU:	分给进程的时间片用完，有更高优先级的进程等等



不能进行进程调度的情况：

- 在处理中断的过程
- 进程在操作系统内核程序临界区
- 原子操作过程中

内核程序临界区一般是用来访问某种内核数据的，比如进程的就绪队列





#### 进程调度的方式

非剥夺调度方式：直到该进程终止或进入阻塞态

剥夺调度方式：可以优先处理更紧急的进程。





#### 进程的切换过程

狭义进程的调度就是指从就绪队列中选一个要运行的进程

进程切换是指一个进程让出处理机，另一个进程占用处理机



广义的进程调度包含了选择一个进程和进程切换两个步骤







### 2.2.3 调度算法的评价标准



- CPU利用率

利用率=忙碌时间/总时间



- 系统吞吐量

系统吞吐量：单位时间内完成的作业数量



- 周转时间

周转时间 = 作业完成时间-作业提交时间

平均周转时间 = 各作业周转时间/作业数

带权周转时间 = 周转时间/作业实际运行时间



- 等待时间

等待时间 = 等待处理机状态时间之和

对进程来说，指进程建立后等待被服务的时间之和

对于作业来说，建立进程后的等待时间，加上作业在外存后备队列等待的时间



- 响应时间

用户提交请求到首次产生响应的时间





​      



### 2.2.4 调度算法：先来先服务，最短作业优先，最高响应比优先



#### 先来先服务（FCFS,First Come First Serve）

算法规则：按照作业/进程到达的先后顺序进行服务

非抢占式算法

优点：公平，算法简单

缺点：某些程序带权周转时间长，FCFS算法对长作业有利，对短作业不利

饥饿：不会产生饥饿





#### 短作业优先（SJF,Shortest Job First）,短进程优先（SPF）

算法规则：最短作业/进程优先得到服务

算法思想：追求最短的平均等待时间，最少的平均等待时间，最少的平均带权周转时间

一般为非抢占式

优点：对短作业有利

饥饿：可能产生饥饿现象





#### 最短剩余时间优先算法（SRTN）,抢占式的短作业优先算法

每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间短，则由新进程抢占处理机





#### 高响应比优先（HRRN，Highest Response Ratio Next）

算法规则：每次调度时先计算各个作业进程的响应比，选择响应比高的作业/进程服务

响应比：等待时间+要求服务时间/要求服务时间

非抢占式

优缺点：综合以上算法

饥饿：不会



![image-20220530161127694](https://s2.loli.net/2022/05/30/diVp1rX3zIMJyEw.png)



这些算法都适用于**批处理系统**









### 2.2.5 调度算法：时间片轮转，优先级调度，多级反馈队列





#### 时间片轮转调度算法

算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片

用于进程调度

抢占式算法

优点：公平，响应快

缺点：由于高频率的进程切换，有一定开销，不分任务紧急程度

饥饿：不会导致饥饿



#### 优先级调度算法

算法规则：每个进程/作业都有各自的优先级，调度时选择优先级最高的作业

用于作业调度，也可用于进程调度

抢占式和非抢占式都有

优缺点：可以区分紧急程度

饥饿：会导致饥饿





根据优先级是否可以动态改变，将优先级分为静态优先级和动态优先级

**静态优先级**:创建进程时确定,之后一直不变。

**动态优先级**:创建进程时有一个初始值,之后会根据情况动态地调整优先级。

**系统进程**优先级高于**用户进程**

**前台进程**优先级高于**后台进程**

操作系统更偏好**I/O型进程**(或称I/O繁忙型进程)







#### 多级反馈队列调度算法

**算法规则**：1.设置多级就绪队列，各级队列优先级从高到低，时间片从小到大

​	2.新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾如果此时已经是在最下级的队列，则重新放回该队列队尾

​	3.只有第k级队列为空时，才会为k+1级队头的进程分配时间片

用于**进程调度**

**抢占式**算法。

**优缺点**：对各类型进程相对公平(FCFS的优点);每个新到达的进程都可以很快就得到响应(RR的优点) ;短进程只用较少的时间就可完成(SPF的优点) ;不必实现估计进程的运行时间(避免用户作假);可灵活地调整对各类进程的偏好程度,比如CPU密集型进程、1/0密集型进程(拓展:可以将因1/0而阻塞的进程重新放回原队列,这样1/0型进程就可以保持较高优先级)

**饥饿**：会导致饥饿



![image-20220530163801196](https://s2.loli.net/2022/05/30/4ArMuXh3TiqfOkV.png)



设置多级就绪队列各级队列优先级丛高到低，时间片从小到大

新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片。若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经在最下级的队列，则重新放回最下级队列队尾

只有第k级队列为空时，才会为k+1级队头的进程分配时间片

被抢占处理机的进程重新放回原队列队尾



![image-20220530164122481](C:\Users\AiYou_\AppData\Roaming\Typora\typora-user-images\image-20220530164122481.png)





















## 2.3 同步与互斥





### 2.3.1 进程同步与进程互斥



#### 进程同步

同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调他们的工作次序而产生的制约关系

有的进程之间需要配合的完成工作，各进程的工作推进需要遵循一定的先后顺序





#### 进程互斥

对临界资源的访问，需要互斥的进行，同一时段只能允许一个进程访问该资源



进程互斥分为**四个部分**：

![image-20220530165552536](https://s2.loli.net/2022/05/30/przqCDOFG5RcXyo.png)

临界区是进程中访问临界资源的代码段

进入区和退出区是负责实现互斥的代码段



进程互斥需要**遵循的原则**：

- 空闲让进：临界区空闲时，应允许一个进程访问
- 忙则等待：临界区正在被访问时，其他试图访问的进程需要等待
- 有限等待：要在有闲时间内进入临界区，保证不会被饥饿
- 让权等待：进不了临界区的进程，需要释放处理机











### 2.3.2 进程互斥的软件实现方法



#### 单标志法

算法思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予

![image-20220601113126311](https://s2.loli.net/2022/06/01/LqxT9Ry6We3cniD.png)

缺点：轮流访问带来的问题是，如果此时允许进入临界区的进程是P0,而P0一直不访问临界区，则临界区空闲，但不允许P1访问。

**违背“空闲让进”原则**







#### 双标志先检查法

算法思想：设置一个布尔型数组flag[]，数组中各个元素用来标记各进程想进入临界区的意愿。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区,如果没有,则把自身对应的标志flag[i]设为true,之后开始访问临界区。

![image-20220601113546651](https://s2.loli.net/2022/06/01/zpAENZlbSGxW8yg.png)

若按照①⑤②⑥③⑦的顺序执行，P0和P1将会同时访问临界区。

因此，双标志先检香法的主要间颗是：违反“**忙则等待**”原则。

原因在于，**进入区的“检查”和“上锁”两个处理不是一气呵成**的。“检查”后，“上锁”前可能发生进程切换。









#### 双标志后检查法

算法思想：先上锁后检查

![image-20220601113802687](https://s2.loli.net/2022/06/01/lUHut5cavK7TCkW.png)

若按照①⑤②⑥.的顺序执行，P0和P1将都无法进入临界区

因此，双标志后检查法虽然解决了“忙则等待”的问题，但是又违背了**“空闲让进”和“有限等待”**原则，会因各进程都长期无法访问临界资源而产生饥饿。









#### Peterson算法

算法思想：孔融让梨，当双方都争着想进入临界区时，可以主动让对方使用临界区

![image-20220601114641319](https://s2.loli.net/2022/06/01/Ogid9xnzDJFlCqs.png)

进入区:
1.主动争取 
2.主动谦让:
3.检查对方是否也想使用,且最后一次是不是自己说了“客气话”

遵循了**空闲让进，忙则等待，有限等待**，**未遵循让权等待**













### 2.3.3 进程互斥的硬件实现方法





#### 中断屏蔽方法

利用“开关中断指令”实现

![image-20220601115633363](https://s2.loli.net/2022/06/01/GbBTOHtxm7P98Ao.png)

缺点：不适用于多处理机，只能用于操作系统内核进程







#### TestAndSet指令

TSL指令是用硬件实现的，执行过程中不允许被中断，只能一气呵成

![image-20220601115920669](https://s2.loli.net/2022/06/01/R2wdtOVrEmKzGkP.png)

若刚开始lock是false,则TSL返回的old值为false,while循环条件不满足，直接跳过循环，进入临界区。

若刚开始lock是true,则执行TSL后old返回的值为true,while循环条件满足，会一直循环，直到当前访问临界区的讲程在退出区讲行“解锁”

缺点：不满足**让权等待**，无法进入临界区的进程会占用CPU并循环执行TSL指令







#### SWAP指令

逻辑上与TSL指令区别不大

![image-20220601120248887](https://s2.loli.net/2022/06/01/1tSYxTmokMfCV37.png)

先记录下此时临界区是否已经被上锁（记录在old变量上)，再将上锁标记lock设置为true,最后检查old,如果old为false，则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。

缺点：不满足**让权等待**

![image-20220601120649697](https://s2.loli.net/2022/06/01/ov2BAuUOWVZTsLb.png)









### 2.3.4 信号量机制



使用信号量来表示系统中某种资源的数量

一对原语：wait(S)和signal(S),括号里的代表信号量，简称P，V操作



#### 整型信号量

用一个整数型的变量来作为信号量，用来表示系统中某种资源的数量

![image-20220601151915204](https://s2.loli.net/2022/06/01/nKDBekOG2Wo5XbT.png)

![image-20220601151936874](https://s2.loli.net/2022/06/01/eoB7gM61l8uq5xc.png)

缺点：仍然存在**让权等待**







#### 记录型信号量

用记录型数据结构表示信号量

![image-20220601152123569](https://s2.loli.net/2022/06/01/NWeADbKGOI9nahu.png)

    在考研题目中wait(S、signal(s)也可以记为

P(S)、V(S),这对原语可用于实现系统资源的“申请”和“释放”

S.value的初值表示系统中某种资源的数目。

对信号量S的**一次P操作意味着进程请求一个单位的该类资源**，因此需要执行S.value--, 表示资源数减1，当S.value<0时表示该类资源已分配完毕，因此进程应调用**block原语进行自我阻塞**（当前运行的进程从运行态→阻塞态)，主动放弃处理机，并插入该类资源的等待队列S.L中。可见，该机制**遵循了“让权等待”原则，不会出现“忙等”现象。**

对信号量S的**一次V操作意味着进程释放一个单位的该类资源**，因此需要执行S.value++,表示资源数加1，**若加1后仍是S.value<=0,表示依然有进程在等待该类资源**，因此应调用**wakeup原语唤醒等待队列中的第一个进程**（被唤醒进程从阻塞态→就绪态）。

![image-20220601152915185](https://s2.loli.net/2022/06/01/YEwcfo7Gy1kBdDb.png)















### 2.3.5 用信号量机制实现进程互斥，同步，前驱关系





#### 实现进程互斥

设置互斥信号量mutex，初值为1

在临界区之前执行P(mutex)

在临界区之后执行V(mutex)

![image-20220601213543141](https://s2.loli.net/2022/06/01/V1E6F3aNr7Uxqbe.png)









#### 实现进程同步

进程同步：要让各并发进程按照要求有序的推进



设置互斥信号量S，初值为0

在前操作之后执行V(S)

在后操作之前执行P(S)

![image-20220601214222511](https://s2.loli.net/2022/06/01/HlxDq9udSbh2GYA.png)







#### 实现前驱关系

![image-20220601214544987](https://s2.loli.net/2022/06/01/hXdcFDalrJbf9Uq.png)



![image-20220601214647592](https://s2.loli.net/2022/06/01/Dc2TOdtQ86hIAjG.png)











### 2.3.6 生产者消费者问题

问题描述：

系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。（注：这里的“产品理解为苯种数坛生产者、消费者共享一个初始为空、大小为的缓冲区。
只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。
只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。
缓冲区是临界资源，各进程必须互斥地访问



分析：

同步关系：

- 缓冲区满时，生产者必须等消费者取出后才能继续生产
- 缓冲区空时，消费者必须等生产者生产才能取出

互斥关系：

- 生产者和消费者必须互斥访问缓冲区



```c++
//初始化信号量
int mutex=1;
int buf=5;
int object=0;

Producer()
{
    p(buf);
    p(mutex);
    把产品放入缓冲区;
    v(mutex);
    v(object);
}

Consumer()
{
	p(object);
    p(mutex);
    把产品取出缓冲区;
    v(mutex);
    v(buf);
}
```

**实现互斥的P操作一定要在实现同步的P操作之后**，否则会造成死锁

![image-20220601215951195](https://s2.loli.net/2022/06/01/QBKv641ridV79LT.png)

生产者执行1，再执行2，由于没有缓冲区，生产者阻塞。此时切换消费者进程，无法访问临界资源。最终导致死锁。









### 2.3.7 多生产者-多消费者

​	桌子上有一只盘子,每次只能向其中放入一个水果。爸爸专向盘子中放苹果,妈妈专向盘子中放橘子,儿子专等着吃盘子中的橘子,女儿专等着吃盘子中的苹果。只有盘子空时,爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时,儿子或女儿可以从盘子中取出水果。
​	用PV操作实现上述过程。

![image-20220601220238314](https://s2.loli.net/2022/06/01/N7PZxAco5qOpvzV.png)



进程同步：

- 爸爸放苹果，女儿才会吃
- 妈妈放桔子，儿子才会吃
- 盘子空了，爸爸妈妈才会放水果；女儿和儿子可以把盘子清空

进程互斥：

- 盘子为临界资源



```c++
int apple=0;
int orange=0;
int plate=0;
int mutex=1;

father()
{
    p(plate);
    p(mutex);
    放苹果;
    v(mutex);
    v(apple);
}

mother()
{
    p(plate);
    p(mutex);
    放桔子;
    v(mutex);
    v(orange);
}

daughter()
{
    p(apple);
    p(mutex);
    取苹果;
    v(mutex);
    v(plate);
}

son()
{
    p(orange);
    p(mutex);
    取苹果;
    v(mutex);
    v(plate);
}
```











### 2.3.8 吸烟者问题

​	假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复（让三个抽烟者轮流地抽烟）

解析：

进程同步：

- 抽烟者拥有自己的原材料才可以抽烟
- 供应者只有在抽烟者抽完烟才可以继续供应

进程互斥：

- 桌子是临界资源



```c++
int offer1=0;
int offer2=0;
int offer3=0;
int finish=0;
int table=1;

producer()
{
        if(i==0)
        	V(offer1);
        else if(i==1)
            V(offer2);
        else if(i==2)
            V(offer3);
        i=(i+1)%3;
		p(finish);
}

smoker1()
{
    p(offer1);
    v(finish);
}

smoker2()
{
    p(offer1);
    v(finish);
}

smoker3()
{
    p(offer3);
    v(finish);
}
```

